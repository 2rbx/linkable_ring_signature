#include "signatures.h"
#include "common.h"
#include "hashes.h"
// printing signature components for debugging

signature* signature_init(int n){
	signature* sign;
	sign = (signature*)malloc(sizeof(signature));
	mpz_init(sign->y0);
	sign->s = (mpz_t*)malloc(n * sizeof(mpz_t));
	sign->c = (mpz_t*)malloc(n * sizeof(mpz_t));
	for(int i = 0 ; i < n ; i++){
		mpz_inits(sign->s[i],sign->c[i],NULL);
	}
	return sign;
}

void print_signature(const signature* sign, int n) {
    printf("Signature contents:\n");
    printf("y0: ");
    gmp_printf("%Zd\n", sign->y0);
    for (int i = 0; i < n; i++) {
        printf("s[%d]: ", i);
        gmp_printf("%Zd\n", sign->s[i]);

        printf("c[%d]: ", i);
        gmp_printf("%Zd\n", sign->c[i]);
    }
}

// generated signature by the PIth member, on message m

void signature_generation(const char* message,const int pi,const key** key_array,int n,signature* sign,const group_parameters* gr){
	gmp_randstate_t state;
	gmp_randinit_default(state);
	gmp_randseed_ui(state,time(NULL));

	//calculating h <- H2(L)
	mpz_t h;
	mpz_init(h);
	size_t size_of_L = 0;
	for(int i = 0 ; i < n ; i++){
		size_of_L += mpz_sizeinbase(key_array[i]->pub,10) + 1;
	}
	char* buffer = (char*)malloc(size_of_L);
	if(!buffer){
		perror("malloc failed in signature generation");
		exit(1);
	}
	size_t offset = 0;
	for (int i = 0; i < n; i++) {
    		offset += gmp_snprintf(buffer + offset, size_of_L - offset, "%Zd", key_array[i]->pub); // putting L in buffer for H2 input 
	}

	H2(h,(unsigned char*)buffer,offset,gr); 
	free(buffer);

	mpz_powm(sign->y0,h,key_array[pi]->pri,gr->p);
	mpz_t* z1 = (mpz_t*)malloc(n * sizeof(mpz_t));
	mpz_t* z2 = (mpz_t*)malloc(n * sizeof(mpz_t));

	mpz_t tmp1,tmp2;
	mpz_inits(tmp1,tmp2,NULL);
	for(int i = 0 ; i < n ; i++){
		mpz_inits(z1[i],z2[i],NULL);
	}
	for(int i = 0 ; i < n ; i++){
		if(i == pi) continue;
		mpz_urandomm(sign->s[i],state,gr->q);
		mpz_urandomm(sign->c[i],state,gr->q);
		mpz_powm(tmp1,gr->g,sign->s[i],gr->p);
		mpz_powm(tmp2,key_array[i]->pub,sign->c[i],gr->p);
		mpz_mul(z1[i],tmp1,tmp2);
		mpz_mod(z1[i],z1[i],gr->p);
		mpz_powm(tmp1,h,sign->s[i],gr->p);
		mpz_powm(tmp2,sign->y0,sign->c[i],gr->p);
		mpz_mul(z2[i],tmp1,tmp2);
		mpz_mod(z2[i],z2[i],gr->p);
	}
	mpz_t r;
	mpz_init(r);
	mpz_urandomm(r,state,gr->q);
	mpz_powm(z1[pi],gr->g,r,gr->p);
	mpz_powm(z2[pi],h,r,gr->p);


	// h1_input <- L || y0 || message || z1[i] || z2[i]
	char* h1_input = build_H1_input(key_array,n,sign->y0,message,z1,z2);  
	mpz_t h1_output;
	mpz_init(h1_output);

	H1(h1_output,(unsigned char*)h1_input,strlen(h1_input),gr); // calculating h1(L||sign->y0||message||z1[i]||z2[i])
	free(h1_input);

	mpz_t cum;
	mpz_init(cum);
	for(int i = 0 ; i < n ; i++){
		if(i != pi) mpz_add(cum,cum,sign->c[i]);
	}
	mpz_mod(cum,cum,gr->q);
	mpz_sub(h1_output,h1_output,cum);
	mpz_set(sign->c[pi],h1_output);
	mpz_mod(sign->c[pi],sign->c[pi],gr->q); // calculating appropriate sign->c[pi]
	mpz_mul(tmp1,sign->c[pi],key_array[pi]->pri);
	mpz_sub(tmp2,r,tmp1);
	mpz_mod(tmp2,tmp2,gr->q);
	mpz_set(sign->s[pi],tmp2); // calculating appropriate sign->s[pi]
	mpz_clears(h,r,h1_output,tmp1,tmp2,NULL);
	for(int i = 0 ; i < n ; i++){
		mpz_clears(z1[i],z2[i],NULL);
	}
	gmp_randclear(state);

}

// given a signature, and message, this function verifies if the signature was generated by someone in the group
int signature_verification(const signature* sign,const key** key_array ,int n,const char* message,const group_parameters* gr){
	mpz_t h;
	mpz_init(h);
	size_t size_of_L = 0;
	for(int i = 0 ; i < n ; i++){
		size_of_L += mpz_sizeinbase(key_array[i]->pub,10) + 1;
	}
	char* buffer = (char*)malloc(size_of_L);
	if(!buffer){
		perror("malloc failed in signature verification 1");
		exit(1);
	}
	size_t offset = 0;
	for (int i = 0; i < n; i++) {
    		offset += gmp_snprintf(buffer + offset, size_of_L - offset, "%Zd", key_array[i]->pub);
	}

	H2(h,(unsigned char*)buffer,offset,gr); 
	free(buffer);
	mpz_t* z1 = (mpz_t*)malloc(n * sizeof(mpz_t));
	mpz_t* z2 = (mpz_t*)malloc(n * sizeof(mpz_t));

	mpz_t tmp1,tmp2;
	mpz_inits(tmp1,tmp2,NULL);
	for(int i = 0 ; i < n ; i++){
		mpz_inits(z1[i],z2[i],NULL);
	}
	for(int i = 0 ; i < n ; i++){
		mpz_powm(tmp1,gr->g,sign->s[i],gr->p);
		mpz_powm(tmp2,key_array[i]->pub,sign->c[i],gr->p);
		mpz_mul(z1[i],tmp1,tmp2);
		mpz_mod(z1[i],z1[i],gr->p);
		mpz_powm(tmp1,h,sign->s[i],gr->p);
		mpz_powm(tmp2,sign->y0,sign->c[i],gr->p);
		mpz_mul(z2[i],tmp1,tmp2);
		mpz_mod(z2[i],z2[i],gr->p);
	}

	// h1_input <- y0 || z1[i] || z2[i]
	char* h1_input = build_H1_input(key_array,n,sign->y0,message,z1,z2);
	mpz_t h1_output;
	mpz_init(h1_output);

	H1(h1_output,(unsigned char*)h1_input,strlen(h1_input),gr); // calculating h1(L||sign->y0||message||z1[i]||z2[i])
	free(h1_input);
	mpz_t cum,addend;
	mpz_inits(cum,addend,NULL);
	for(int i = 0 ; i < n ; i++){
		mpz_mod(addend,sign->c[i],gr->q);
		mpz_add(cum,cum,addend);
	}
	mpz_mod(cum,cum,gr->q);
	mpz_clears(tmp1,tmp2,addend,h,NULL);
	int valid;
	if(mpz_cmp(cum,h1_output) == 0) valid = 1;
	else valid = 0;
	mpz_clears(h1_output,cum,NULL);
	for(int i = 0 ; i < n ; i++){
		mpz_clears(z1[i],z2[i],NULL);
	}
	free(z1);
	free(z2);
	return valid;

}

int link_verification(const signature* sign1,const signature* sign2){
	return mpz_cmp(sign1->y0,sign2->y0) == 0 ? 1 : 0;
}

void clear_signature(signature* sign,int n){
	mpz_clear(sign->y0);
	for(int i = 0 ; i < n ; i++) {
		mpz_clear(sign->s[i]);
		mpz_clear(sign->c[i]);
	}
	free(sign->s);
	free(sign->c);
	free(sign);
}
